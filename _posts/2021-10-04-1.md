---
title: "IP 주소 개념 정리"
categories:
  - backend-system
---

<!--excerpt open-->

컴퓨터 네트워크에서 서로를 인식하고 소통하려면 각각의 기기에게 할당될 수 있는 고유 키가 필요합니다. 그렇지 않으면 통신하려고 하는 기기가 무엇인지를 알 방법이 없죠. 이러한 고유 키가 IP 주소입니다. 우리는 일상 속에서 주민등록번호, 차량번호, 계좌번호, 주문번호, 티켓번호 등의 고유식별번호를 접합니다. IP 주소는 기기별로 고유하게 할당되는 것이 아닌 네트워크 연결에 따라 할당되는 번호이기에 주문번호, 티켓번호와 비슷하다고 볼 수 있겠습니다.

<!--excerpt close-->

## IPv4

IP version 4 (IPv4) 는 32비트 주소로 우리에게 가장 익숙한 형태의 IP 주소입니다. 0에서 255 사이의 수 네 개로 구성되어 **172.16.254.1**와 같은 형태의 값을 가집니다. IPv4로 만들어낼 수 있는 주소의 개수는 256의 네 제곱인 총 4,294,967,296개가 됩니다.

> 세 자릿수를 사용하면서 왜 최대한으로 사용할 수 있는 999가 아닌 255까지만 사용할까요? 컴퓨터는 0과 1로 이루어진 언어라고 흔히 알고있지요. 그렇기에 컴퓨터에 저장하는 정보는 우리에게 익숙한 10진수가 아닌 2진수의 형태가 됩니다. IPv4의 각각의 부분은 8비트, 즉 8개의 0 또는 1로 이루어짐에 따라 2의 8제곱인 총 256가지의 수가 표현되고, 0을 포함하여 255까지의 세 자릿수까지 표현이 가능한겁니다. 이를 8비트를 나타내는 용어인 옥텟(octet)이라고 부르기도 하며 IPv4는 네 개의 옥텟으로 구성된다고 말할 수 있습니다.

## 네트워크 ID와 호스트 ID

IP 주소는 네트워크를 구분하는 네트워크 ID와 해당 네트워크에 속한 사용자를 나타내는 호스트 ID로 나뉩니다. 즉 같은 네트워크에 연결된 다른 기기라면 동일한 네트워크 ID를 공유하며, 서로를 호스트 ID로만 구분하는 겁니다. 그렇다면 IP 주소에서 어디까지가 네트워크 ID이고 어디까지가 호스트 ID일까요?

### Classful Addressing

Classful Addressing에서는 IP 주소의 범위에 따라 Class A, B, C, D, E(Reserved Address)로 나눠지며, 각 Class 별로 네트워크 ID와 호스트 ID를 구분하는 지점이 달라집니다.

<figure>
  <img src="/images/1/1.png" alt="image1">
  <figcaption>출처: https://www.researchgate.net/figure/1-1-IPv4-Classes-Ranges_fig1_260622269</figcaption>
</figure>

**Class A:** 첫 옥텟은 네트워크 ID, 나머지 세 옥텟은 호스트 ID. 2<sup>24</sup> - 2 = 16,777,214 개의 호스트를 가질 수 있음.

**Class B:** 처음 두 옥텟은 네트워크 ID, 나머지 두 옥텟은 호스트 ID. 2<sup>16</sup> - 2 = 65,534 개의 호스트를 가질 수 있음.

**Class C:** 처음 세 옥텟은 네트워크 ID, 마지막 옥텟은 호스트 ID. 2<sup>8</sup> - 2 = 254 개의 호스트를 가질 수 있음

**Class D:** 멀티캐스트용 주소

**Reserved Address:** 연구 또는 항후 사용 목적으로 예약된 주소

> 호스트 개수에서 2를 빼는 이유는 해당 네트워크의 첫 IP 주소는 Network IP로, 마지막 IP 주소는 Broadcast ID로 할당되기 때문입니다.

네트워크 ID 부분을 <span style="color: red">X</span>라 하고 호스트 ID 부분을 <span style="color: blue">Y</span>라 한다면 다음과 같은 형태가 됩니다.

| Class | 네트워크 ID (<span style="color: red">X</span>) / 호스트 ID (<span style="color: blue">Y</span>) | IP 주소 범위                |
| ----- | ------------------------------------------------------------------------------------------------ | --------------------------- |
| A     | <span style="color: red">XXX</span>.<span style="color: blue">YYY.YYY.YYY</span>                 | 1.0.0.0 ~ 126.255.255.255   |
| B     | <span style="color: red">XXX.XXX</span>.<span style="color: blue">YYY.YYY</span>                 | 128.0.0.0 ~ 191.255.255.255 |
| C     | <span style="color: red">XXX.XXX.XXX</span>.<span style="color: blue">YYY</span>                 | 192.0.0.0 ~ 223.255.255.255 |

### Classless Addressing

Classful Addressing는 네트워크 ID와 호스트 ID를 각각의 Class 별로 나누어주었지만, 네트워크의 크기가 다양해지면서 Classful Addressing의 한계가 드러나게 되었습니다. 낭비되는 IP 주소가 많아져서 IP 주소의 고갈이 우려되었죠.

이에 Classless Addressing이 등장하게 되었는데, 이는 네트워크 ID와 호스트 ID를 나누는 지점을 Class에 상관없이 유동적으로 할당하여 IP 주소 낭비를 줄여줄 수 있었습니다.

Classful의 경우 IP 주소 만으로 네트워크 ID와 호스트 ID의 구분점을 알 수 있지만, Classless의 경우에는 구분점을 나타내는 값을 지정해줘야 합니다. 대표적으로 Subnet Mask와 CIDR(Classless Inter-Domain Routing)가 있습니다.

#### Subnet Mask

IP 주소가 32비트, 즉 32개의 0 또는 1로 구성이 되어있다고 봤을 때 Subnet Mask는 네트워크 ID 부분을 1로, 호스트 ID를 0으로 구분합니다. 아래의 예시를 봅니다.

|             | 10진수 표기   | 2진수 표기                          |
| ----------- | ------------- | ----------------------------------- |
| IPv4 주소   | 192.168.0.13  | 11000000.10101000.00000000.00001101 |
| Subnet Mask | 255.255.255.0 | 11111111.11111111.11111111.00000000 |

Subnet Mask의 2진수 표기에서 1에 해당하는 자릿수는 네트워크 ID로 구분하여 192.168.0이 네트워크 ID가 되고 마지막 자리인 13은 호스트 ID가 되는 겁니다.

|             | 10진수 표기   | 2진수 표기                          |
| ----------- | ------------- | ----------------------------------- |
| IPv4 주소   | 172.16.1.9    | 10101100.00010000.00000001.00001001 |
| Subnet Mask | 255.255.224.0 | 11111111.11111111.11100000.00000000 |

Subnet이 무조건 옥텟 단위만으로 존재하리라는 법은 없습니다. 위의 경우에는 IPv4 주소의 첫 19비트가 네트워크 ID가 됨에 따라 Subnet Mask는 2진수 표기에서 첫 19자리 수에 1이 들어가고 나머지에 0이 들어갑니다.

요약하자면 Subnet Mask는 0과 1로 네트워크 ID 부분과 호스트 ID 부분을 구분하는 방법입니다.

#### CIDR

Subnet의 구분을 네트워크 ID 자릿수의 개수로 나타낼 수도 있습니다. 이를 Classless Inter-Domain Routing (CIDR) 이라고 합니다. 이는 보통 IP 주소 뒤에 슬레시 (/) 다음에 자릿수를 나타내는 방식으로 표현됩니다.

| 10진수 표기       | 2진수 표기                             |
| ----------------- | -------------------------------------- |
| 63.255.173.183/20 | 00111111.11111111.10101101.10110111/20 |
|                   |                                        |

위의 경우 63.255.173.183을 2진수로 나타내었을 때 처음 20자리를 네트워크 ID로 본다는 의미입니다.

## Public IP / Private IP

<figure>
  <img src="/images/1/2.png" alt="image2">
  <figcaption>출처: https://www.avg.com/en/signal/public-vs-private-ip-address</figcaption>
</figure>

IP 주소 고갈에 대한 또 다른 해법으로 Public IP / Private IP가 도입됩니다. 외부에서 접속할 수 있는 하나의 Public IP를 공유기에 할당하고, 공유기에 연결된 기기들에 대해서 Private IP를 할당하게 되는 겁니다. 하나의 IP 주소로 여러 기기를 연결할 수 있게 되었죠.

각 IPv4 Class 별로 다음의 주소들을 Private IP 주소로 사용합니다.

| Class | Private IP 주소 범위          |
| ----- | ----------------------------- |
| A     | 10.0.0.0 ~ 10.255.255.255     |
| B     | 172.16.0.0 ~ 172.31.255.255   |
| C     | 192.168.0.0 ~ 192.168.255.255 |

## Gateway

IP 주소 정보를 보면 기본 Gateway라는 주소가 있는 것을 볼 수가 있습니다. 이는 다른 네트워크와 연결해주는 접근점을 말하며 흔히 공유기의 주소가 되는 겁니다. 주로 로컬 네트워크에서 인터넷으로 연결해주는 역할을 하게 되지요. Router라고 부르기도 합니다.

## DNS (Domain Name System) 서버

<figure>
  <img src="/images/1/3.png" alt="image3">
  <figcaption>출처: https://www.seobility.net/en/wiki/DNS_Server</figcaption>
</figure>

우리가 흔히 이용하는 네이버, 유튜브, 구글 등등의 웹사이트에 접속할 때 해당 웹사이트의 서버 IP가 필요합니다. 그러나 우리가 브라우저 주소창에 IP 주소를 일일이 쳐서 접속하지 않고 naver.com, youtube.com, google.com 같은 도메인 이름을 사용합니다.

DNS 서버는 이러한 도메인 이름을 받아 해당 서비스의 IP 주소를 내어주는 역할을 합니다. 따라서 해당 웹사이트의 IP 주소를 외우고 다니지 않아도 되는 것이죠.

통신사별로 DNS 서버가 존재합니다.

| 통신사 | DNS 서버 주소                  |
| ------ | ------------------------------ | ------------------------------ |
| KT     | 기본 DNS 서버 : 168.126.63.1   | 보조 DNS 서버 : 168.126.63.2   |
| LG U+  | 기본 DNS 서버 : 164.124.101.2  | 보조 DNS 서버 : 203.248.252.2  |
| SKT    | 기본 DNS 서버 : 219.250.36.130 | 보조 DNS 서버 : 210.220.163.82 |
| Google | 기본 DNS 서버 : 8.8.8.8        | 보조 DNS 서버 : 8.8.4.4        |

## DHCP 서버

기기별로 IP 주소를 직접 정해놓고 고정된 정적 IP 주소를 사용할 수도 있지만, 모든 기기가 매 순간 사용되는게 아니라면 사용되지 않는 IP 주소는 낭비됩니다. 또한, 새로운 기기를 네트워크에 연결할때 중복되지 않는 IP 주소를 매번 수동으로 찾는 것도 번거롭죠.

상황에 따라 IP 주소를 자동으로 할당해주는 방법을 생각해볼 수 있는데, Dynamic Host Configuration Protocol (DHCP) 서버가 이런 일을 수행하게 됩니다.

## IP 주소 확인하기

자 이제 각자 IP 주소를 확인하는 방법을 살펴볼까요?

콘솔창에서 윈도우의 경우 ipconfig, 맥이나 리눅스의 경우 ifconfig를 치게 되면 다음과 같은 정보가 출력됩니다.

![image4](/images/1/4.png)

저의 경우 VMware 가상머신을 사용하면서 생성된 IP 주소와 Wifi로 연결된 IP 주소가 나오네요. 저는 윈도우를 사용하고 있는데 윈도우의 경우 ipconfig /all을 입력하면 Gateway, DNS 서버 등의 더 많은 정보를 볼 수 있습니다.

![image5](/images/1/5.png)

저는 DHCP를 사용하여 동적 IP 주소를 가져오고 있고, 할당된 IPv4주소는 192.168.0.2이며, 서브넷 마스크가 255.255.255.0인 걸 봤을 때 192.168.0이 네트워크 ID네요.

공유기(게이트웨이)의 주소는 192.168.0.1이고 DNS 서버 주소를 봤을 때 저는 SKT DNS 서버를 사용하고 있습니다.

IPv6 주소는 따로 언급하지 않았는데 이는 IPv4 주소의 32비트 주소의 부족함을 해결하기 위한 또다른 방법으로 무려 128비트로 확장된 주소입니다.

위의 주소는 전부 Private IP이기 때문에 위의 정보로는 저의 컴퓨터에 침투할 수 없습니다. Public IP를 알기 위해서는 구글에 ‘what is my ip’를 검색하면 확인할 수 있습니다.

![image6](/images/1/6.png)